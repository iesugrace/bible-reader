#!/usr/bin/env python3
# Author: Joshua Chen
# Date: 2015-02-28
# Finished: 2015-03-01, took 22 hours
# Updated: 2015-10-27, add audio play back
# Location: Shenzhen
# Description: read/listen bible, take notes, record progress

import sys, os, time, subprocess, tempfile
import ZODB, transaction
from BTrees.OOBTree import OOBTree
import signal

prog_path = os.path.realpath(__file__)
prog_dir  = os.path.dirname(prog_path)
lib_dir   = os.path.join(prog_dir, 'lib')
sys.path.insert(0, lib_dir)

from util.common import getContainer
from textproc.wrap import Wrap
from interact import interact
from util.recorder import Recorder
from applib import pageOut
import timeutils
from config import Config

basedir   = os.path.join(prog_dir, 'data')
appdata   = os.path.join(basedir,  'appdata')
userdata  = os.path.join(basedir,  'userdata')
db_path   = os.path.join(appdata,  'bible.zodb')    # bible database
audiodir  = os.path.join(appdata,  'audio')         # bible audio directory
log_path  = os.path.join(userdata, 'log.zodb')      # database holding logs
note_path = os.path.join(userdata, 'note.zodb')     # database holding notes

try:
    config = Config()
except:
    print(sys.exc_info()[1], file=sys.stderr)
    exit(1)

def stdtime(second=None):
    if not second: second = time.time()
    return timeutils.isotime(second)

def stddate(second=None):
    if not second: second = time.time()
    return timeutils.stddate(second)

def confirm(prompt='please confirm [y/n]: '):
    while True:
        i = interact.readstr(prompt=prompt)
        if i == 'y':
            return True;
        elif i == 'n':
            return False;

def makeRequest(name, default, datatype, reader, desc):
    """
    create a request entry, used for interact.readMany
    """
    suffix = (' [%s]: ' % default) if default else ': '
    prompt = desc + suffix
    if reader:
        actual_reader = (lambda prompt, default: reader(prompt, default))
    else:
        actual_reader = reader
    return dict(name=name, prompt=prompt, datatype=datatype, default=default, reader=actual_reader)


class Log(Recorder):
    def __init__(self, db_path, bible):
        self.bible = bible
        Recorder.__init__(self, db_path)

    def get_latest_totd(self):
        """In days of 2016-11-18, multi-section mode is
        being developing, old log records is transformed
        into the new format.
        """
        def transform(record):
            """Pack the old record into a dictionary with key 'all'."""
            old_record_type_name = 'all'
            infos = record[1]
            if isinstance(infos, list):
                infos = {old_record_type_name: infos}
                record[1] = infos
            return record

        filter = (lambda k, v: v[0] == 'totd')
        pairs = sorted(Recorder.search(self, filter))
        if pairs:
            record = self.db[pairs[-1][0]]
            return transform(record)
        else:
            return None

    def readLogInfo(self, avail_books, data=None):
        """ Interactively read information for a log entry
        """
        if data:
            names = self.bible.db['name_list']
            if data[0]:
                stime = stdtime(data[0])
            else:
                stime = None
            if data[1]:
                etime = stdtime(data[1])
            else:
                etime = None
            # numbers shown on the screen is one greater
            if data[2][0]:
                sbook   = names.index(data[2][0]) + 1
            else:
                sbook = None
            schap   = data[2][1]
            sverse   = data[2][2]
            if data[3][0]:
                ebook   = names.index(data[3][0]) + 1
            else:
                ebook = None
            echap   = data[3][1]
            everse   = data[3][2]
        else:
            stime = etime = sbook = schap = None
            sverse = ebook = echap = everse = None

        def getBook(prompt, default, books=avail_books):
            while True:
                index, name = self.bible.pickBook(
                                    prompt=prompt,
                                    default=default)
                book_num = index + 1
                if book_num not in books:
                    msg = '%s (%s) is not in the configured set'
                    msg = msg % (name, book_num)
                    print(msg)
                    interact.readstr('--- press enter to retry ---', default='')
                else:
                    break
            return name

        _ = lambda t, d: t + (' [%s]: ' % d if d else ': ')
        res = {}

        # collect the time info
        res['stime'] = interact.readstr(_('start time', stime), default=stime)
        res['etime'] = interact.readstr(_('end time', etime), default=etime)

        # collect the starting location
        while True:
            res['sbook'] = getBook(_('start book', sbook),
                                   default=sbook)
            res['schap'] = interact.readint(_('start chapter', schap),
                                            default=schap)
            res['sverse'] = interact.readint(_('start verse', sverse),
                                            default=sverse)
            if self.bible.has_ver(
                        res['sbook'],
                        res['schap'],
                        res['sverse']):
                break
            print('invalid location')
            interact.readstr('--- press enter to retry ---', default='')

        # collect the ending location
        while True:
            res['ebook'] = getBook(_('end book', ebook), default=ebook)
            res['echap'] = interact.readint(_('end chapter', echap),
                                            default=echap)
            verse_count  = self.bible.count_verse_of_chap(
                                res['ebook'],
                                res['echap'])
            prompt_str   = _('end verse (max %s)' % verse_count, everse)
            res['everse'] = interact.readint(prompt_str, default=everse)
            if self.bible.has_ver(
                        res['ebook'],
                        res['echap'],
                        res['everse']):
                break
            print('invalid location')
            interact.readstr('--- press enter to retry ---', default='')

        return res

    def makeLogEntry(self, data=None, cate='normal'):
        self.bible.setup_sections(self.bible.config.TOTD_sections)
        snames = self.bible.ordered_section_names[:]
        snames.append('-- whole bible --')
        snames.append('-- done --')

        # for multiple sections to share the same time info,
        # an empty refdata shall be created to carry the time
        # info across section iteration.
        default_data = [None, None, [None, None, None],
                        [None, None, None], None]
        saved_stime = saved_stime = None
        log_val = {}

        while True:
            i, name = interact.printAndPick(
                        snames,
                        prompt='choice: ',
                        lineMode=True)
            if name == snames[-1]:
                break
            if name == snames[-2]:
                sname = 'default'
                sdata = [(sname, self.bible.config.default_section, 0)]
                self.bible.setup_sections(sdata, totd=False)
            else:
                sname = name
                self.bible.setup_sections(self.bible.config.TOTD_sections)
            sec = self.bible.sections[sname]

            if not data:
                refdata = default_data
            else:
                refdata = data.get(sname, default_data)
            if saved_stime:
                refdata[0] = saved_stime
                refdata[1] = saved_etime

            i = self.readLogInfo(sec.books, data=refdata)
            sect_log_val = []
            tc = timeutils.strtosecond
            sect_log_val.append(tc(i['stime']))
            sect_log_val.append(tc(i['etime']))
            sect_log_val.append([i['sbook'], i['schap'], i['sverse']])
            sect_log_val.append([i['ebook'], i['echap'], i['everse']])
            count = self.bible.countVerse(
                        i['sbook'], i['schap'], i['sverse'],
                        i['ebook'], i['echap'], i['everse'],
                        sec)
            sect_log_val.append(count)
            log_val[sname] = sect_log_val

            # preserve the time info for the next section.
            saved_stime = sect_log_val[0]
            saved_etime = sect_log_val[1]

        entry = []

        # allow user to set the log type
        choices = ['totd', 'normal']
        default = choices.index(cate) + 1
        index, cate = interact.printAndPick(choices,
                        prompt='pick the log type [%s]: ' % default,
                        lineMode=True, default=default)
        entry.append(cate)
        entry.append(log_val)
        return entry

    def add(self, ent=None):
        if not ent: ent = self.makeLogEntry()
        key = str(int(time.time()))
        Recorder.add(self, key, ent)

    def edit(self):
        entries = sorted(Recorder.list(self))
        keys    = [k for k, v in entries]
        logs    = [self.LogWrapper(v[-1], self) for k, v in entries]
        index, item = interact.printAndPick(logs, prompt='pick one: ')

        key     = keys[index]
        oldcate = entries[index][-1][0]
        oldent  = entries[index][-1][-1]
        ent     = self.makeLogEntry(oldent, oldcate)
        Recorder.save(self, key, ent)

    class LogWrapper:
        """
        it is a try, without changing the format of the existing
        log entries, provide a __str__ method.
        """
        def __init__(self, data, parent):
            self.data = data
            self.parent = parent
        def __str__(self):
            return self.parent.format(self.data)

    def delete(self):
        entries = sorted(Recorder.list(self))
        keys    = [k for k, v in entries]
        logs    = [self.LogWrapper(v[-1], self) for k, v in entries]
        index, item = interact.printAndPick(logs, prompt='pick one: ')
        c = interact.readstr('sure? [y/n]: ')
        if c == 'y':
            Recorder.delete(self, keys[index])

    def format(self, ent):
        """Format the log entry, return a string, the
        log entry is a dict with multiple key-val pairs.
        For backward compatibility, we also handle old
        format log record.
        """
        def format_(info):
            spos = '%s{%s:%s}' % tuple(x for x in info[2])
            epos = '%s{%s:%s}' % tuple(x for x in info[3])
            line = '%21s - %-21s (%-3d vers)' % (spos, epos, info[4])
            return line
        def sort_infos(ent):
            """Sort the sections according to the book number"""
            key = lambda p: self.bible.book_name_to_number(p[1][2][0])
            return sorted(ent.items(), key=key)

        lines = []
        if isinstance(ent, list):
            info = ent
            line = format_(info)
            lines.append(line)
            stime = stdtime(info[0])
            etime = stdtime(info[1])
            dura = (info[1] - info[0]) // 60
            line = '[%s] - [%s] (%-3d mins)' % (stime, etime, dura)
            lines.insert(0, line)
        else:
            infos = sort_infos(ent)
            total_vers = 0
            for name, info in infos:
                total_vers += info[-1]
                line = format_(info)
                lines.append(line)
            stime = stdtime(info[0])
            etime = stdtime(info[1])
            dura = (info[1] - info[0]) // 60
            line = '[%s] - [%s] (%-3d mins, %-3d vers)' % (
                        stime, etime, dura, total_vers)
            lines.insert(0, line)
        return '\n'.join(lines)

    def showEntries(self, items):
        """List the log entries"""
        for key, (cate, val) in items:
            if isinstance(val, list):
                length = 54
            else:
                length = 64
            if cate == 'totd':
                bar = '-' + 'T' + '-' * length
            else:
                bar = '-' + 'N' + '-' * length
            text = self.format(val)
            print('%s\n%s' % (bar, text))

    def list(self):
        self.opendb()
        items = sorted(i for i in self.db.items())
        self.showEntries(items)

    def search(self):
        """Support searching for book name,
        case is ignored.
        """
        keyword = interact.readstr(prompt='book name: ')
        def filter(k, v):
            """Handle both single and multiple section log records"""
            log = v[-1]
            names = []
            if isinstance(log, list):
                names.append(log[2][0])
                names.append(log[3][0])
            else:
                for v in log.values():
                    names.append(v[2][0])
                    names.append(v[3][0])
            names = list(map(str.lower, names))
            return keyword.lower() in names

        entries = Recorder.search(self, filter=filter)
        self.showEntries(entries)


class Note(Recorder):
    """
    A class for managing simple records.
    The records stored in a flat fashion, that is, one key, one value
    """
    def read_asso_vers(self, text=''):
        if not text:
            text = 'Enter the associated verses or leave it empty'
            text += '\nFormat: Genesis{1:1,3,5-6;2;5-6;3:4},Exodus{2:10}\n'
        return interact.readstr(text, default='')

    def add(self):
        second    = time.time()
        asso_vers = self.read_asso_vers()
        content   = self.editContent()
        key       = str(second)
        record    = {'time': second, 'verse': asso_vers, 'content': content}
        Recorder.add(self, key, record)

    def list(self, number=True):
        from io import StringIO
        from textproc.page import more

        self.opendb()
        ents = Recorder.search(self, filter=(lambda k,v: True))
        ents = sorted(ents, reverse=True)
        buffer = StringIO()
        sys.stdout = buffer
        for i, (k, v) in enumerate(ents, 1):
            if number:
                print('-' * 10, i, '-' * 10)
            else:
                print('-' * 20)
            self.show_note(v)
        sys.stdout = sys.__stdout__
        more(StringIO(buffer.getvalue()), 20)

    def search(self):
        self.opendb()
        keyword = interact.readstr('keyword: ')
        filter  = lambda k,v: keyword in v['content'].decode()
        vals = Recorder.search(self, filter)
        for k, v in vals:
            self.show_note(v)

    def show_note(self, v):
        print(stdtime(v['time']), v['verse'],
                v['content'].decode().rstrip(), sep='\n')

    def edit(self):
        self.list()
        self.opendb()
        keys = sorted(self.db.keys(), reverse=True)
        record_count = len(keys)
        i = interact.pickInRange(end=record_count, prompt='pick one: ')
        key = keys[i]
        val = self.db[key]
        asso_vers = val['verse']
        content = val['content']
        # edit the associated verses
        vers = self.read_asso_vers('old verses: ' + asso_vers + '\nleave empty to keep: ')
        if vers:
            val['verse'] = vers
        val['content'] = self.editContent(content=content)
        Recorder.save(self, key, val)

    def editContent(self, content=None):
        # edit the content
        tmpfile = tempfile.NamedTemporaryFile(delete=False)
        if content:
            tmpfile.write(content)
            tmpfile.flush()
        cmd = ['vi', tmpfile.name]
        p = subprocess.Popen(cmd)
        p.communicate()
        p.wait()
        tmpfile.seek(0)
        content = tmpfile.read()
        os.unlink(tmpfile.name)
        return content

    def delete(self):
        self.list()
        self.opendb()
        keys = sorted(self.db.keys(), reverse=True)
        record_count = len(keys)
        i = interact.pickInRange(end=record_count, prompt='pick one: ')
        c = interact.readstr('sure? [y/n]: ')
        if c == 'y':
            self.db.pop(keys[i])
        self.commit()


class Section:
    """A section of the Bible."""
    def __init__(self, data):
       """Shall not do self.data = data directly,
       since we have a __setattr__ defined.
       """
       if not self.__dict__.get('data'):
        self.__dict__['data'] = data

    def __getattr__(self, name):
        return self.data.get(name)

    def __setattr__(self, name, value):
        self.data[name] = value


class Bible():
    def __init__(self, db_path, config):
        self.dbConnection = ZODB.connection(db_path)
        self.db = getContainer(self.dbConnection.root, 'main')
        self.start_time = time.time()
        self.ver_count = 0
        self.config = config

    def setup_sections(self, sect_data, totd=True):
        sections = {}
        for name, books, limit in sect_data:
            section = Section({'name': name,
                               'books': books,
                               'totd_limit': limit,
                               'next_book': 0,
                               'next_chap': 0,
                               'next_ver': 0,
                               'ver_count': 0})
            sections[name] = section
            if totd:
                section.totd_stat = self.set_start_loc(section)
        self.sections = sections
        self.ordered_section_names = [x[0] for x in sect_data]

    def has_ver(self, book, chap, ver):
        """ Check if the given verse exists.
        """
        verse_count = self.count_verse_of_chap(book, chap)
        return True if (1 <= ver <= verse_count) else False

    def count_verse_of_chap(self, book, chap):
        """ Count all verses of the given chapter.
        There is a key named 'desc' in chapters of book Psalm,
        these keys must be removed before counting length.
        """
        book = self.db.get(book, None)
        if not book: return 0
        chap = book.get(chap, None)
        if not chap: return 0
        chap.pop('desc', None)  # remove key 'desc'
        return len(chap)

    def more_chap(self, book, chap):
        if (chap + 1) in self.db[book]:
            return True
        else:
            return False

    def more_book(self, book, section):
        """If there is book after the given book 'book' in the section"""
        name_list = self.db['name_list']
        book_num = name_list.index(book) + 1
        idx = section.books.index(book_num)
        return idx != len(section.books) - 1

    def set_start_loc(self, section, location=None):
        """Set the start location, that is the starting
        book, starting chapter, starting verse, in the
        given section.
        """
        if location:
            book, chap, ver = location
            ver += 1
            return self._set_start(book, chap, ver, section)

        logger = Log(log_path, bible=self)
        latest_log = logger.get_latest_totd()
        logger.closedb()

        # advance to the next verse in the section
        if latest_log and section.name in latest_log[1]:
            location = latest_log[1][section.name][-2]
            book, chap, ver = location
            ver += 1
        # there is no log of the section, maybe it's the first
        # time to run the app or it's a new defined section.
        else:
            book_idx = section.books[0] - 1
            book = self.db['name_list'][book_idx]
            chap = 1
            ver = 1
        return self._set_start(book, chap, ver, section)

    def _set_start(self, book, chap, ver, section):
        # if it's a valid verse
        if self.has_ver(book, chap, ver):
            section.start_book = book
            section.start_chap = chap
            section.start_ver = ver
        # if there are more chapters left in the current book
        elif self.more_chap(book, chap):
            section.start_book = book
            section.start_chap = chap + 1
            section.start_ver = 1
        # if there are more books left in the section
        elif self.more_book(book, section):
            section.start_book = self.next_book(book, section)
            section.start_chap = 1
            section.start_ver = 1
        # the current book is the last one in the section, start over.
        # since we start over when hit the end, this block can be
        # merged with the one above.
        else:
            section.start_book = self.next_book(book, section)
            section.start_chap = 1
            section.start_ver = 1

    def collectLogValues(self):
        log_val = {}
        for name in self.ordered_section_names:
            sec = self.sections[name]
            val = []
            val.append(self.start_time)
            val.append(time.time())
            val.append([sec.start_book, sec.start_chap, sec.start_ver])
            val.append([sec.next_book, sec.next_chap, sec.next_ver])
            val.append(sec.ver_count)
            log_val[name] = val
        return log_val

    def log_record(self, log_val=None, cate='normal'):
        if not log_val:
            log_val = self.collectLogValues()
        entry = list()
        entry.append(cate)
        entry.append(log_val)
        logger = Log(log_path, bible=self)
        logger.add(entry)

    def list_log(self):
        logger = Log(log_path, bible=self)
        logger.list()

    def next_chapter(self, s):
        """Advance the position to the next chapter in the bible
        within the given section identified by 's'.

        book_changed will be set to True when advance to the next book.
        """
        stat, book_changed = (True, True)
        if s.next_book == 0:                                    # the first time
            s.next_book = s.start_book                          # to call this method
            s.next_chap = s.start_chap
            s.next_ver = s.start_ver
        else:
            if self.more_chap(s.next_book, s.next_chap):        # there are still
                s.next_chap += 1                                # chapters in the
                s.next_ver = 1                                  # current book
                book_changed = False
            elif self.more_book(s.next_book, s):                # current book end,
                s.next_book = self.next_book(s.next_book, s)    # but there are still
                s.next_chap = 1                                 # books in the section
                s.next_ver = 1
            else:                                               # start over,
                s.next_book = self.next_book(s.next_book, s)    # can be merged with
                s.next_chap = 1                                 # the above block
                s.next_ver = 1
        return stat, book_changed

    def next_book(self, cur_book, section):
        """Return the book name of the next book after
        the current book 'cur_book', if the current book
        is the last book in the section, return the first
        book name of the section."""
        name_list = self.db['name_list']
        current_idx_all = name_list.index(cur_book)
        current_book_num = current_idx_all + 1
        if current_book_num == section.books[-1]:
            res_book_num = section.books[0]
        else:
            # the book numbers in the section may not be continuous,
            # so we can not simply make the book number one greater,
            # instead, we pick the one whose index is one greater.
            current_idx_sect = section.books.index(current_book_num)
            res_book_num = section.books[current_idx_sect + 1]
        return name_list[res_book_num - 1]

    def pickLocation(self, section):
        """Pick the starting location in the given section"""
        def getBook(prompt, default):
            index, name = self.pickBook(prompt=prompt, default=default)
            return name

        requests = []
        requests.append(makeRequest('sbook', None, int, getBook, 'start book'))
        requests.append(makeRequest('schap', None, int, None,    'start chapter'))
        requests.append(makeRequest('sverse', None, int, None,    'start verse'))

        while True:
            print('\n--- %s ---\n' % section.name)
            i = interact.readMany(requests)
            book, chap, vers = i['sbook'], i['schap'], i['sverse']
            book_num = self.book_name_to_number(book)
            if book_num not in section.books:
                book_name = self.book_number_to_name(book_num)
                msg = '%s (%s) is not in the configured set "%s"'
                msg = msg % (book_name, book_num, section.name)
                print(msg)
                interact.readstr('--- press enter to retry ---', default='')
                continue
            if self.has_ver(book, chap, vers):
                self._set_start(book, chap, vers, section)
                break
            else:
                print('invalid location: %s{%s:%s}' % (book, chap, vers))
                interact.readstr('--- press enter to retry ---', default='')

    def confirmStartLoc(self):
        """
        give the user a chance to pick another location for TOTD.
        """
        text = 'start at:'
        for name in self.ordered_section_names:
            sec = self.sections[name]
            text += ('\n  %s{%s:%s}' % (sec.start_book,
                                      sec.start_chap,
                                      sec.start_ver))
        text = '%s\npick another? [n]: ' % text
        c = interact.readstr(prompt=text, default='')
        if c in ('y', 'Y'):
            for name in self.ordered_section_names:
                sec = self.sections[name]
                self.pickLocation(sec)

    def fetch_section_verses(self, section):
        """Fetch the verses from the books in the specified section,
        according to the last position and amount limit of the section."""

        total = section.totd_limit
        verse_data = []
        start_book = None
        start_chap = None

        while total > 0:
            stat, book_changed = self.next_chapter(section)
            if not stat:
                break
            book_name = section.next_book
            chap_num = section.next_chap
            ver_num = section.next_ver
            if not start_book:
                start_book = book_name
                start_chap = chap_num
            if book_changed:
                verse_data.append(('extra', ('\n%s\n\n' %
                                self.db[book_name]['desc']), None))
            chap_data = self.db[book_name][chap_num]
            ver_keys = list(chap_data.keys())
            # only valid for Psalms because only book Psalms
            # may have key 'desc' in its chapters' keys.
            if 'desc' in ver_keys:
                ver_keys.remove('desc')
            ver_keys = sorted([k for k in ver_keys if k[1] >= ver_num])
            for key in ver_keys:
                verse_data.append((chap_num, key[1], chap_data[key]))
                section.next_ver += 1
                section.ver_count += 1
                total -= 1
                # after all verses are collected, we continue
                # to collect the rest of the current chapter
                if (total <= 0 and not self.has_ver(
                        book_name, chap_num, section.next_ver)):
                    # roll back the section.next_ver to the real ending one
                    section.next_ver -= 1
                    break
        return verse_data

    def show_totd(self, audio=False):
        verse_data = []
        audio_list = None
        for name in self.ordered_section_names:
            sec = self.sections[name]
            verses = self.fetch_section_verses(sec)
            verse_data.extend(verses)
        if audio:
            audio_list = self.compose_audio_list()
        self.dbConnection.close()
        self.play(verse_data, audio_list)

    def play(self, verse_data, audio_list):
        """Show the verse, play the audio."""
        if audio_list:
            audio_child = self.play_audio(audio_list)
        tmpfile = tempfile.NamedTemporaryFile(delete=False)
        self.show_verse(tmpfile, verse_data)
        tmpfile.close()
        cmd = ['vi', '-R', tmpfile.name]
        p = subprocess.Popen(cmd)
        p.communicate()
        os.unlink(tmpfile.name)
        p.wait()
        if audio_list:
            os.kill(audio_child, 9)

    def compose_audio_list(self):
        """Search the audio file and compose a path name list
        by checking the starting and ending chapter of each section.
        """
        audio_list = []
        for name in self.ordered_section_names:
            sec = self.sections[name]
            chpts = self.fetch_chap_range(
                        sec.start_book,
                        sec.start_chap,
                        sec.next_book,
                        sec.next_chap,
                        sec.books)
            books = sec.books
            l = ['%s/%s.mp3' % (b, c) for b, c in chpts]
            audio_list.extend(l)
        return audio_list

    def chapterKeys(self, section):
        """Read the keys of the current chapter"""
        book_name = section.next_book
        chap_num = section.next_chap
        ver_num = section.next_ver
        ver_keys = list(self.db[book_name][chap_num].keys())

        # the 'desc' only shows up in Psalms, we don't want it here
        if 'desc' in ver_keys:
            ver_keys.remove('desc')
        ver_keys = sorted([versenum for paragraph, versenum in ver_keys
                            if versenum >= ver_num])
        return ver_keys

    def countVerse(self, startBook, startChapter, startVerse,
                   endBook, endChapter, endVerse, section):
        """Count the total verses of the given range in the section"""

        section.next_book = startBook
        section.next_chap = startChapter
        section.next_ver = startVerse

        count = 0
        stop  = False
        while True:
            ver_keys = self.chapterKeys(section)
            for key in ver_keys:
                count += 1
                if (section.next_book == endBook
                        and section.next_chap == endChapter
                        and key == endVerse):
                    stop = True
                    break
            if stop:
                break
            else:
                ok, junk = self.next_chapter(section)
                if not ok: break

        return count

    def show_verse(self, ofile, verse_data):
        from system.term import Term
        w = Wrap()
        x = Term()
        limit = x.cols() - 13
        for p1, p2, content in verse_data:
            if p1 == 'extra':
                ofile.write(p2.encode())
                continue
            chap = p1
            ver = p2
            loc_str = '{%s:%s}' % (chap, ver)
            white = ' ' * len(loc_str)
            pad = loc_str
            while content:
                wrapped, content = w.wrap(content, limit).read()
                if wrapped.isspace(): continue
                wrapped = '%s %s\n' % (pad, wrapped.lstrip())
                ofile.write(wrapped.encode())
                pad = white

    def parseLocations(self, locations):
        """ Parse the location parameters

        Location example:

            Genesis/1:1,3,5-6;2;5-9;3:4 Exodus Revelation/1:1

        inter-book separator: multiple spaces
        book/chapter separator: slash, none for the whole book
        inter-chapter separator: semi-colon
        chapter/verse separator: colon
        inter-verse separator: comma
        chapter/verse representation: single number or a range,
        """
        import re
        trueMatcher  = lambda chap, ver: True
        def _matcher(chapter, verse, single, rng):
            """ Verify it the given chapter/verse match
            """
            if [1 for c1, c2 in rng if c1 <= chapter <= c2]:
                return True
            chapInfo = single.get(chapter, None)
            if chapInfo is None:
                return False
            if not chapInfo:    # empty, means the whole chapter
                return True
            if [1 for v1, v2 in chapInfo['range'] if v1 <= verse <= v2]:
                return True
            if verse in chapInfo['single']:
                return True
            return False

        def _match_book(x, names, fullnames):
            m = [z for z in fullnames if z.lower().startswith(x.lower())]
            if m:
                idx = fullnames.index(m[0])
                return names[idx]
            else:
                return None

        result       = []
        allBookNames = self.db['name_list']
        allBookFullnames = self.db['fullname_list']
        if not locations:
            return [(x, trueMatcher) for x in allBookNames]

        for bookText in re.split(' +', locations):
            # bookText example:
            # Genesis/1:1,3,5-6;2;5-9;3:4   <-- book, chapter, verse
            # Revelation                    <-- only book name
            if not bookText: continue
            bookParts = bookText.split('/')
            psdName   = bookParts[0]
            bookName  = _match_book(psdName,
                                    allBookNames,
                                    allBookFullnames)
            if not bookName:
                print('invalid book name %s' % psdName)
                continue
            if len(bookParts) == 1: # entire book
                result.append((bookName, trueMatcher))
                continue
            chapInfos   = {}
            chapRngList = []
            chapTexts   = bookParts[1].split(';')
            for chapText in chapTexts:
                # chapText example:
                # 1:1,3,5-6     <-- chapter with verse
                # 1-3           <-- chapter range
                # 3             <-- only chapter
                if not chapText: continue
                chapParts = chapText.split(':')
                chapter   = chapParts[0]
                if '-' in chapter:  # will ignore the verse part
                    chapRange = [int(i) for i in chapter.split('-')]
                    chapRngList.append(chapRange)
                    continue
                if len(chapParts) == 1: # entire chapter
                    chapInfos[int(chapter)] = {}
                    continue
                verseList    = []
                verseRngList = []
                verseTexts   = chapParts[1].split(',')
                for verseText in verseTexts:
                    # verseText example:
                    # 1     <-- one verse
                    # 5-6   <-- verse range
                    if not verseText: continue
                    if '-' in verseText:
                        verseRange = [int(i) for i in verseText.split('-')]
                        verseRngList.append(verseRange)
                    else:
                        verseList.append(int(verseText))
                chapInfos[int(chapter)] = {
                    'single': verseList,
                    'range': verseRngList,
                }
            matcher = lambda c, v, x=chapInfos, y=chapRngList: _matcher(c, v, x, y)
            result.append((bookName, matcher))
        return result

    def _list(self, locations=None, pat=None, chapterwise=False):
        """ List the bible verses
        if the 'locations' is provided, list only those verses,
        if the 'pat' is provided, filter with the pattern,
        if the chapterwise is True, do another kind of search.
        """
        if chapterwise:
            self.search_chapter(pat)
            return

        import re
        db        = self.db
        vals      = []
        hlcolor   = 'red'
        flags     = re.DOTALL|re.IGNORECASE
        try:
            bookInfos = self.parseLocations(locations)
        except ValueError:
            print('wrong argument: %s' % locations, file=sys.stderr)
            help()
            exit(1)

        # this version displays a sorted result,
        # sort within one book.
        for book_name, matchLoc in bookInfos:
            book_data = db[book_name]
            book_verses = []
            for chap_num, chap_data in book_data.items():
                if chap_num == 'desc': continue
                for key, content in chap_data.items():
                    if key == 'desc': continue  # we don't search in description
                    verse = key[-1]
                    if not matchLoc(chap_num, verse): continue
                    if pat and not re.search(pat, content, flags): continue
                    if pat and os.isatty(sys.stdout.fileno()):
                        content = self.highlight(pat, content, flags, hlcolor)
                    entry = {'book': book_name,
                             'chap': chap_num,
                             'verse': verse,
                             'content': content}
                    book_verses.append(entry)
            vals += sorted(book_verses, key=(lambda x: (x['chap'], x['verse'])))
        self.dbConnection.close()
        pageOut(vals)

    def highlight(self, pat, content, flags, hlcolor):
        """ Hightlight the pattern 'pat' with 'hlcolor'
        in the text 'content' with shell color scheme.
        """
        import re
        mapping = {
            'black': '0;30',
            'red': '0;31',
            'green': '0;32',
            'brown': '0;33',
            'blue': '0;34',
            'magenta': '0;35',
        }
        color = mapping.get(hlcolor, '0;31')
        pat   = '(?P<matched>%s)' % pat
        repl  = '\033[%sm\g<matched>\033[0m' % color
        return re.sub(pat, repl, content, flags=flags)

    def search_chapter(self, pat, chapterwise=False):
        """ search the bible contents for the given pattern, within one chapter. """
        if not self.chapter_initialized():
            print('chapter data not initialized, run "bible build_chapter_data" to init',
                    file=sys.stderr)
            return

        import re
        db = self.db
        matches = []

        chap_data = db['chapters']['data']
        for book_name, chap_num, chap_text in chap_data:
            match_texts = re.findall(pat, chap_text, re.IGNORECASE|re.DOTALL)
            for text in match_texts:
                # verse_numbers can be empty if matched on one single verse
                verse_numbers = re.findall('\|([0-9]+)\|', text)
                if not verse_numbers:
                    verse_numbers = [self.find_verse_number(chap_text, text)]
                else:
                    verse_numbers = [int(n) for n in verse_numbers]
                    verse_numbers.insert(0, verse_numbers[0] - 1)   # the first verse of the match
                # collect verses
                all_verses_data = re.split('\|[0-9]+\|', chap_text)[1:]
                first_verse_number = verse_numbers[0]
                last_verse_number = verse_numbers[-1]
                header = (book_name, chap_num, first_verse_number, last_verse_number)
                verse_block = all_verses_data[slice(first_verse_number - 1, last_verse_number)]
                matches.append((header, verse_block))

        try:
            for header, block in matches:
                print('%s{%s:%s-%s}' % header)
                print('-' * 50)
                num_with_verse = ['%s: %s' % x for x in enumerate(block, header[2])]
                list(map(print, num_with_verse))
                print()
        except Exception as e:
            # BrokenPipeError
            if e.errno == 32:
                exit(0)

    def find_verse_number(self, chap_text, text):
        """ find the verse number out by locating the
        part of the verse, that is, the 'text', in the
        whole text of the chapter, the 'chap_text'. """
        import re
        idx = chap_text.index(text)
        left_part = chap_text[:idx]
        numbers = re.findall('\|([0-9]+)\|', left_part)
        return int(numbers[-1])

    def chapter_initialized(self):
        """ check if the chapter data is initialized. """
        try:
            if self.db['chapters']['initialized']:
                return True
        except:
            pass
        return False

    def build_chapter_data(self):
        """ concatenate verses of a chapter together to build
        a big text for 'chapter search'. """
        db = self.db

        # return if already done
        if self.chapter_initialized():
            return

        chapters = {'data': []}

        # all books, 'name_list' is sorted
        for book_name in db['name_list']:
            book_data = db[book_name]
            # all chapters, sorted
            book_data = [x for x in book_data.items() if x[0] != 'desc']
            book_data = sorted(book_data, key=(lambda x: int(x[0])))
            for chap_num, chap_data in book_data:
                chap_verses = []
                # one chapter, sorted
                for key, content in chap_data.items():
                    if key != 'desc':
                        chap_verses.append((key[-1], content))
                # concatenate
                chap_verses = sorted(chap_verses)
                chap_text   = ''.join(['|%s|%s' % (num, data) for (num, data) in chap_verses])
                chapters['data'].append((book_name, chap_num, chap_text))
                print('building %s, chapter %s' % (book_name, chap_num))
        chapters['initialized'] = True
        db['chapters'] = chapters
        transaction.commit()

    def pickBook(self, prompt='select [TOTD]: ', default=None):
        # print all the books names with the numbers,
        # and let the user pick one by number
        names = self.db['name_list']
        count = len(names)
        lists = ['%2d.%-8s ' % (i + 1, name)
                    for i, name in zip(range(count), names)]
        pad = [''] * 4
        g1 = lists[:13]
        g2 = lists[13:26]
        g3 = lists[26:39]
        g4 = lists[39:48] + pad
        g5 = lists[48:57] + pad
        g6 = lists[57:] + pad
        for items in zip(g1, g2, g3, g4, g5, g6):
            for item in items:
                print(item, end='')
            print()
        return interact.pick(names, default=default, prompt=prompt)

    def read(self, audio=False):
        """ play the associated audio files sequentially
        if the 'audio' parameter is True.
        """
        idx, book_name = self.pickBook(default=-1)

        # prevent accidental close before loggin the read.
        setupSignalHandler()

        # user did not enter anything, but press the Enter,
        # we show the TOTD
        if idx == None:
            self.setup_sections(self.config.TOTD_sections)
            self.confirmStartLoc()
            self.show_totd(audio)
            cate = 'totd'
        else:
            section_data = [('default', self.config.default_section, 0)]
            self.setup_sections(section_data, totd=False)
            self.show_normal_read(book_name, audio)
            cate = 'normal'
        if (not confirm('log this read? [y/n]: ') and
            confirm('-- DOUBLE CONFIRM --\ndo not log? [y/n]: ')):
            pass
        else:
            self.log_record(cate=cate)

    def show_normal_read(self, book_name, audio=False):
        verse_data = []
        book_data = self.db[book_name]
        book_items = sorted([(k, v) for k, v in book_data.items()
                             if k != 'desc'])
        verse_data = []
        for chap, chap_data in book_items:
            chap_items = sorted([(k, v) for k, v in chap_data.items()
                                 if k != 'desc'])
            for key, content in chap_items:
                verse_data.append((chap, key[1], content))

        sname = 'default'
        self.sections[sname].start_book = book_name
        self.sections[sname].start_chap = verse_data[0][0]
        self.sections[sname].start_ver = verse_data[0][1]
        self.sections[sname].next_book = book_name
        self.sections[sname].next_chap = verse_data[-1][0]
        self.sections[sname].next_ver = verse_data[-1][1]
        self.sections[sname].ver_count = len(verse_data)
        self.ver_count = len(verse_data)

        audio_list = None
        if audio:
            audio_list = self.compose_audio_list()
        self.dbConnection.close()
        self.play(verse_data, audio_list)

    def count_chaps(self, book_name):
        """ count the chapters in a book """
        book_data = self.db[book_name]
        return len([0 for k, v in book_data.items() if k != 'desc'])

    def book_name_to_number(self, name):
        """ convert the book name to its number in the 66 books """
        return self.db['name_list'].index(name) + 1

    def book_number_to_name(self, number):
        """ convert the book number to its name in the 66 books """
        return self.db['name_list'][number - 1]

    def play_audio(self, audio_list):
        """ play the bible audio in the given file list"""
        child = os.fork()
        if child == 0:
            nullfile = os.open(os.devnull, os.O_RDWR)
            os.dup2(nullfile, sys.stdout.fileno())
            os.dup2(nullfile, sys.stderr.fileno())
            os.dup2(nullfile, sys.stdin.fileno())

            os.chdir(audiodir)
            params = [config.player] + audio_list
            os.execvp(config.player, params)
            exit(0)
        else:
            return child

    def fetch_chap_range(self, start_book, start_chap, end_book, end_chap,
                         avail_books, loop=True):
        """Fetch all chapters' book number and chapter number pair
        in the given range. If the end book is less than the start
        book and the loop is True, count from the start book up to
        the end of the available books then continue from the start
        of the available books up to the end book.
        """
        start_book = self.book_name_to_number(start_book)
        end_book = self.book_name_to_number(end_book)
        start_idx = avail_books.index(start_book)
        end_idx = avail_books.index(end_book)
        if end_book < start_book and loop:
            book_nums = avail_books[start_idx:]
            book_nums += avail_books[:end_idx+1]
        else:
            book_nums = avail_books[start_idx:end_idx+1]

        res = []

        # collect all chapters of all books
        for book_num in book_nums:
            book_name = self.book_number_to_name(book_num)
            chap_count = self.count_chaps(book_name)
            chapters = range(1, chap_count + 1)
            res.extend([(book_num, c) for c in chapters])

        # when there is only one book in the book number list,
        # and the end chap is less than the start chap, the
        # following striping code will fail, here we double the
        # list 'res' to fulfill the code below.
        if end_chap < start_chap and len(book_nums) == 1:
            res = res + res

        # remove from the first to the start_chap,
        # and from the end_chap plus 1 to the end.
        start_idx = start_chap - 1
        end_idx = end_chap - chap_count
        if end_idx:
            res = res[start_idx:end_idx]
        else:
            res = res[start_idx:]
        return res

    def showLogMenu(self):
        logger = Log(log_path, bible=self)
        logger.menu()


def help():
    bname = os.path.basename(sys.argv[0])
    msg = """Usage: %s command arguments

%s read [-a|--audio]
%s list [-l location] [-p pattern]
%s csearch -p pattern
%s log
%s ll
%s note
%s anote
%s plan [count]
%s help

Example arguments for list command's -l option:

Rev                     <-- whole book
Exodus/2:10             <-- book/chapter:verse
Gene/1:1,3,5-6;2;5-6    <-- chapterA:...;chapterB
Exodus/2:10 Rev         <-- multiple books
""" % ((bname,) * 10)
    print(msg)


def read():
    if len(sys.argv) == 3 and sys.argv[2] in ('-a', '--audio'):
        audio = True
    else:
        audio = False
    b = Bible(db_path, config)
    b.read(audio)


def ll():
    b = Bible(db_path, config)
    b.list_log()


def log():
    b = Bible(db_path, config)
    b.showLogMenu()


def note():
    n = Note(note_path)
    n.menu()


def anote():
    n = Note(note_path)
    n.add()


def _list(args):
    pat = locations = None
    try:
        while args:
            if args[0] == '-p':
                pat = args[1]
                args = args[2:]
            elif args[0] == '-l':
                locations = args[1]
                args = args[2:]
            else:
                args.pop(0)
    except:
        help()
        exit(1)
    if not locations and not pat:
        help()
        exit(1)
    b = Bible(db_path, config)
    b._list(locations=locations, pat=pat)


def csearch(args):
    try:
        if args[0] == '-p':
            pat = args[1]
    except:
        help()
        exit(1)
    b = Bible(db_path, config)
    b._list(pat=pat, chapterwise=True)


def plan(args):
    """Show the next 'count' TOTD reading plan.
    The procedure of calculating the positions are
    the same as when actually reading the Bible,
    except that no log record written.
    """
    if len(args):
        try:
            count = int(args[0])
        except ValueError:
            print('invalid value: %s' % args[0])
            help()
            exit(1)
    else:
        count=10
    bible = Bible(db_path, config)
    logger = Log(log_path, bible=bible)
    latest_log = Log(log_path, bible).get_latest_totd()
    interval = 86400    # one day
    if latest_log:
        if isinstance(latest_log[1], list):
            loginfo = latest_log[1]
            second = loginfo[1] + interval
        else:
            loginfo = list(latest_log[1].values())[0]
            second = loginfo[1] + interval
    else:
        second = time.time()
    second = int(second)
    second = timeutils.strtosecond(timeutils.stddate(second))

    bible.setup_sections(config.TOTD_sections)
    log_items = []
    for x in range(count):
        # advance the location for collecting log data.
        for name in bible.ordered_section_names:
            sec = bible.sections[name]
            bible.fetch_section_verses(sec)
        log_val = bible.collectLogValues()
        for v in log_val.values():
            v[0] = second
            v[1] = second
        log_items.append([None, ('totd', log_val)])
        second += interval

        # set the start location for the next iteration
        for name in bible.ordered_section_names:
            sec = bible.sections[name]
            book = sec.next_book
            chap = sec.next_chap
            ver = sec.next_ver
            bible.set_start_loc(sec, [book, chap, ver])
            sec.next_book = 0   # method next_chapter needs this
            sec.ver_count = 0   # clear the counter

    logger.showEntries(log_items)


def build_chapter_data():
    b = Bible(db_path, config)
    b.build_chapter_data()

action_map = {
        'read': read,
        'll': ll,
        'log': log,
        'note': note,
        'anote': anote,
        'help': help,
        'list': _list,
        'csearch': csearch,
        'plan': plan,
        'build_chapter_data': build_chapter_data, # hidden, for admin only
}


def setupSignalHandler():
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    signal.signal(signal.SIGQUIT, signal.SIG_IGN)
    signal.signal(signal.SIGTSTP, signal.SIG_IGN)


if __name__ == '__main__':
    if len(sys.argv) < 2:
        help()
        exit(1)
    action = action_map.get(sys.argv[1], help)

    try:
        if action == _list or action == csearch:
            if len(sys.argv) < 4:
                help()
            else:
                action(sys.argv[2:])
        elif action == plan:
            action(sys.argv[2:])
        else:
            action()
    except KeyboardInterrupt:
        print('', file=sys.stderr)
        exit(1)
    except (BrokenPipeError, IOError):
        sys.stderr.close()  # get rid of the error message of 'broken pipe error'.
        exit(1)

